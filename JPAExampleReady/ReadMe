ReadMe
Spring JPA [Ready Application] [Preferred Style over the MVC]


JPA spring is object based programming and database has the tables not objects 
so we need to map particular class to particular tables.

Traditional Approach:
so through tables we are getting all record and converted into the  objects, but
now we don't need to do this conversion manually 
and we have different framework that do this functionality called is ORM 


ORM [Object relationship mapping ]
so tables represent the object in ORM, so hibernate and iBAt framework defined these functionality 


Hiberante FrameWork:

hibernate has it's own implementation of ORM , 
hiberante different functionality and session and object are behaving and interaction as compare to the iBAT.
so conversion between hiberanate and iBAT is very difficult so java provide the JPS specification 


JPS API specification: [JPS "Java persistance API Specificaion"]
 
java created the standard specification e.g JPS specification 
so this specification used when creating the implementation 
so java provide the specification and we need to create the implementation
JPS specification through the ORM provider 

so through the JPSAPI we can convert the iBAT and Hibernate easily, so need to implement the JPS API specification

so in our application POM.XML used [spring-boot-starter-data-jpa] that used hibernate

**************************************** How to create the tables[entity] with spring JPA **********************************************
Entity[POJO] should be inside of the package =: very important
[All other packages inside the package com.JPAExampleReady package , e.g entity  shoud be like that package com.JPAExampleReady.entity;]
you need to create the database in mysql only 
Don't need to create the tables in JPA hibernate framework, because the entities are the tables, and it will create all tables that represent entities
in the spring at run time 

Step # 01 create entity and
Step # 02 configure properties file 
 these annotation for the entity , e.g "student" etc are very important
 
@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder

Now, check in the database that the all entity class are created as the tables 



Note:
[Sql query is different than the JQL query: 
JQL Query : In Jql Query we need to used the spring class(Entity) name as the the table name not the actual database table name for the query
written in the repository interface . similarly columns are consider as the filed name not the actual column in the database for the query written in the interface]
 

As we know the structure of spring boot

[controller -> 
	service [Interface and interfaceImplemenation] ->
		repository [Interface only (as we extended by Spring based JPA Repository)] ->
																				database[entity (POJO)]]

Here, as we created first entity so now second step is the repository
First Step : Create entity[PoJO] with constraints
Second Step:create the repository [Interface]

Note: if we want to store the two entity in to the single table and in application we need to treat in two different class [two different entity]
so we need to used the two annotation in both class separetly, so here two classes(two entities)
one entity act alike a main entity and other entity act like a derived entity 
so in this application Student entity is main entity and the Guardian entity is the derived entity 

Specially for the parent child relationship:

Student [Entity] :
Student entity we need to add the annotation @Embaded in the data fields area, like below 
	@Embedded
    private Guardian guardian;

Guardian [Entity]:
Guardian entity we need to put the annotation @Embeddable at the top of the class name and don't put the @Entityon that class because
this is not seperate table, actually this class is the part of the same tabel "student"
**************************************** Test Class **********************************************
In all test cases keep in mind no "new" keyword used.

For this Application we are not creating the REST API, we are only testing the repository.
For the REST API see the "SpringBootReady"" git

Note : before creating the JUnit test make sure that the actual .java file [that going to generate the test file in the correct folder] , 
otherwise test will not execute
Testing:

so for the testing, click on the repository and create the "Juunit test Case" click on the left side panel on the particular 
repository java file, create new go to the bottom and create "Junit test Case"


Annotation difference testing:
@DataJPATest : technically we that is annotation that used for the testing, because it create the data at the real database and than when finished
testing it removed all the created data for the testing purpose from the database.

@SpringBootTest: but, for this application we are using this annotation: that annotation actually changed the data from the database
and don't removed the created data from the database. [It's dangerous]  


**************************************** JPA repository Method **********************************************
very very Importnat	

	/*for the interface singanture name formate are very important,
	 * e.g findBy+properties_Field_Name[first alpha should be capital](same dataType with same dataField)
	 *   findByStudentId(Long studentId); 
	 *   so complete signature will be List<Student> findByStudentId(Lomg studentId);
	 */

Another Point
        /*
	  * for the Guardian class
	  * List<Student> findBy+[object of that class in main class [first alpha cap]]+[field name of Gurdian class [first alpha cap]](same)
	  */

For teh single record fetching put signatire with the entity name, e.g 
Student findByFirstNameAndLastName(String firstName,String lastName);


JQL Query :

JQl query is little bit different as compare to teh standard SQL Query

e.g 	 
@Query("select s from Student s where s.emailAddress =?1")
	 Student getStudentByEmailAddress(String emailAddress); //here method name start with the "get...." not find, beacuse its query
     
Here in query, ?1 represent thefirst parameter from the input
the datafiled used for the filteration is from the POJO data field e.g  "emailAddress" from student class



//Native Here we are usiing the sql table name and column intead of the class entiry and datafield
	    @Query(
	            value = "SELECT * FROM student_table s where s.email_address = ?1",
	            nativeQuery = true
	    )
	    Student getStudentByEmailAddressNative(String emailAddress);
        
//Native Named Param : Here we are usiing the sql table name and column intead of the class entiry and datafield, but for the input parameter we need to used the datafiled of entity class
	    @Query(
	            value = "SELECT * FROM student_table s where s.email_address = :emailAddress",
	            nativeQuery = true
	    )
	    Student getStudentByEmailAddressNativeNamedParam(
	           
               @Param("emailAddress") String emailAddress
	    ); 
        
//Update Query : update query has return type int  [Important]

    //update Query : 
	    
	    @Modifying
	    @Transactional
	    @Query(
	            value = "update student_table set first_name = ?1 where email_address = ?2",
	            nativeQuery = true
	    )
	    int updateStudentNameByEmailId(String firstName, String emailAddress);





************************************************** @Embeddable and @Embedded ********************************************************

Specially for the parent child relationship:

Student [Entity] :
Student entity we need to add the annotation @Embaded in the data fields area, like below 
	@Embedded
    private Guardian guardian;

Guardian [Entity]:
Guardian entity we need to put the annotation @Embeddable at the top of the class name and don't put the @Entityon that class because
this is not seperate table, actually this class is the part of the same tabel "student"



************************************************** Native Queries Example ********************************************************
//Native Here we are usiing the sql table name and column intead of the class entiry and datafield
	    @Query(
	            value = "SELECT * FROM student_table s where s.email_address = ?1",
	            nativeQuery = true
	    )
	    Student getStudentByEmailAddressNative(String emailAddress);
  


************************************************** Query Named Params ********************************************************
//Native Named Param : Here we are usiing the sql table name and column intead of the class entiry and datafield, but for the input parameter we need to used the datafiled of entity class
	    @Query(
	            value = "SELECT * FROM student_table s where s.email_address = :emailAddress",
	            nativeQuery = true
	    )
	    Student getStudentByEmailAddressNativeNamedParam(
	           
               @Param("emailAddress") String emailAddress
	    ); 



************************************************** @Transactional & @Modifying Annotation ********************************************************
//Update Query : update query has return type int  [Important]

    //update Query : 
	    
	    @Modifying
	    @Transactional
	    @Query(
	            value = "update student_table set first_name = ?1 where email_address = ?2",
	            nativeQuery = true
	    )
	    int updateStudentNameByEmailId(String firstName, String emailAddress);




************************************************** JPA One to One Relationship [course and courseMaterial]********************************************************

between course and coursematerial has 1 to 1 relationhip
So CourseId in Course table 
and CourseMaterial has courseMaterial ID
now the courseId is F.K in CourseMaterial table 


	/*
	 * courseMaterial has to have the courses, so it cannot stand alone, so here we need to add the Course
	 * @OneToOne : so for that we need to define the one to one mapping,
	 * 
	 * @JoinColumn:now we need to defined for which particular column foreign key will be applied by, 
	 * so in parantheses we need to defined for which particulr column we can join the table 
	 * so for the course,  the course material refernce to the courseID
	 */

at repotest file:
courseMatRepo.save(courseMat);  [unidirectional CourseMaterial to Course only [not vice versa]]
	/*
	 * this simple is not work because the transient error, so we need to make the data persistant
	 * so making the course persistant, we neee to cascade the data [so in simple term uptill now we are going to save the coursematerial 
	 * table that connected with the course table, but the course table does not have any data, that called the transient error],
	 * so the solution of the transient error is the cascading [Cascading mean if there is no data available for the course so cascade try to persist this course]
	 * so there are several cascade type available so we go to the courseMaterial  file and under one-to one mapping put cascade = CascadeType.ALL,
	 * 
	 */ 
	 /*
	 /*
	 * very Important:very Important:[till now we only defined uni-deirectional one to one mapping  very Important:very Important: ]
	 * so if you see the courseMaterial table there is no mappping of course in it,
	 * because courseMaterial mapped to Course not vice versa
	 
     Making bidirectional Mapping:
     ***************************************Making bidirectional Mapping: **************************************
     Uni & Bi directional Relationship
     * so go to the course 
	 * As we alredy defined the joining into the courseMaterial class., so here we don't need to do again 
	 * just mentioed that its mapped by on the top of the other class object in course class inorder to make it bidirectional
	 *
     
     
     **************course class *******************
	@OneToOne(
			mappedBy = "course"
			)
	private CourseMaterial courseMaterial;
	 */



    **************courseMaterial class **************
    @OneToOne(
                cascade = CascadeType.ALL,
                fetch = FetchType.LAZY,  //two type of fetching 1: eager [bring the course and course material both] 2: lazy [bring only courseMaterial ]
                optional = false // we are saying here when we save the course courseMaterial is required, not optional
                )
        @JoinColumn(
                name = "course_Id",
                referencedColumnName = "courseId" //from Course POJO
                )
        private Course course;

        Note:     
        //if you want to exclude course table from the courseMaterial table :use the table name at the CourseMaterial POJO above class name
        @ToString(exclude = "course")
************************************************** JPA One to Many Relationship [teacher to Course]********************************************************

one teacher teach many course

Inside the teacherentity class[pojo]

/*
		 * one to Many relationship: one teacher teach many courses [one to many],
		 * First defined Cascade : so we need to defined the cascade here 
		 * Then join the course table and teacher table by the PK teacherID and course table shoudl have the teacherID as a F.K
		 */
		@OneToMany(
				cascade = CascadeType.ALL
				)
		@JoinColumn(
				
				name= "techer_Id",
				referencedColumnName = "techerId"
				
				)
		
		private List<Course> courses;

note :[So, till now the course table altered with the one more column "teacherId" and the Techer table is created]



************************************************** JPA Many to One Relationship []********************************************************

rather than defined the one to many relationship, its better to many to one relationship , and it would be there are many course availabl 
and many teacher can teach the same course, 
so we will chosing the teacher and see teach will teach wich course [Many to one]




************************************************** JPA Many to Many Relationship [course and student]*******************************************************

//******************************** Many to Many [course and student]****************************
		/*
		 * for the Many to Many relationship we need two annotation
		 * First : @ManyToMany(...
		 * second :  @JoinTable(...
		 * 
		 * For the @JoinTable we need two joinColumns configurations
		 * 
		 * First[joinColumns]: first with join table of same class [Course]
		 * 
		 * joinColumns = @JoinColumn(
	     *              name = "course_id",
	     *               referencedColumnName = "courseId"
	     *       ),
		 * 
		 * Second [inverseJoinColumns]: second with join table of other joined table class [Student]
		 * inverseJoinColumns = @JoinColumn(
	     *               name = "student_id",
	     *               referencedColumnName = "studentId"
	     *       )
		 * 
		 */ 





************************************************** Paging and Sorting ********************************************************

Every repository implement the pagination by default , paganation tell how many data will apear on the page on some othermethod as well,
sorting on page element as well, e.g data on page will appear on taht style qoted on the page 










